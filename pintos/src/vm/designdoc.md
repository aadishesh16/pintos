# Project 3: Virtual Memory

## ჯგუფის წევრები

* გიორგი დანელია <gdane14@freeuni.edu.ge>
* ლუკა კირია <lkiri15@freeuni.edu.ge>
* ირაკლი ქანთარია <ikant14@freeuni.edu.ge>
* საბა თათანაშვილი <stata14@freeuni.edu.ge>

## 1. Frame Table
### მონაცემთა სტრუქტურები და ფუნქციები
**vm/frame.h vm/frame.c**
```
struct list frame_table;
struct lock frame_lock;

struct frame
{
  void * kpage;
	void * upage;  
	struct list_elem frame_elem;
	struct thread * t;
};

void frame_init(void);
uint8_t * alloc_frame(enum palloc_flags flags, struct supp_page_entry * p);
void free_frame(void * kpage);

```
ფიზიკურ მეხსიერებაში არსებული ფრეიმების კონტროლისთვის, უფრო კონკრეტულად მეხსიერების სვაპინგის წასამართავად ვიყენებთ `frame` სტრქუტურას, რომელიც მეხსიერების ერთ ფეიჯს შეესაბამება და მის შესახებ შეიცავს დამატებით ველებს. შესაბამისად ლისტი frame_table ინახავს მოცემულ ფრეიმ სტრუქტურებს.
- ```kpage``` - მისამართი ფიზიკური მეხსიერების ჯეიჯზე
- ```upage``` - მისამართი ვირტუალური მეხსიერების ფეიჯზე რომელიც მას შეესაბამება
- ```frame_elem``` - გამოიყენება სტრუქტურის `frame_table` ლისტში შესანახად
- ```t``` - სრედი, რომელსაც მოცემული ფეიჯი ეკუთვნის
უნდა აღინიშნოს რომ რეალურად ფრეიმების კონტროლისთვის მოცემული ველები არ არის საკმარისი, თუმცა ამ ეტაპისთვის პროექტში არ გვაქვს იმპლემენტირებული სვაპინგი. შესაბამისად ამჟამად არსებული ფრეიმ სტრუქტურა და ფრეიმ ლისტი უბრალოდ წინაპირობაა მომავალში განსახორციელებელი დამატებითი ფუნქციონალისთვის.

### ალგორითმები

გვაქვს მოდიფიკაციები `process.c` ფაილის ფუნქციაში, `setup_stack()`. პროგრამის გაშვებისას ფიზიკური მეხსიერების გამოყოფა ხდება მხოლოდ სტეკში პირველი ფეიჯის ჩატვირთვისას. ამიტომ ამავე ფუნქციაში ვიძახებთ `alloc_frame()`ს, რომელიც `palloc_get_page()`-ის მეშვეობით მეხსიერებაში გამოყოფს ფეიჯს და მის მისამართს გვიბრუნებს, ფრეიმ სტრუტურის შესაბამისი ველების შევსებასთან ერთად.
ფრეიმები ასევე გამოიყოფა lazy loading-ის დროს, როდესაც წინასწარ დამეპილი ვირტუალური ფეიჯების(იხ. ქვემოთ) შესაბამისი ფიზიკური ფრეიმების მოთხოვნა ხდება იუზერის პროგრამის მუშაობის პროცესში.

### სინქრონიზაცია

რადგან `frame_table` ლისტი არის კერნელისთვის გლობალური სტრუქტრუა, მასზე წვდომა აქვთ სხვადასხვა პროგრამებს, ამიტომ საჭიროა ამ ლისტზე შესაძლო ქმედებების სინქრონიზაცია. ამისთვის გვაქვს `frame_lock` ლოკი, რომლითაც ვლოქავთ ლისტს, მასში ახალი ფრეიმის ჩადგების ან სასურველი ფრეიმის მოძებნის დროს.

## 2. Supplemental page table, Lazy loading and stack growth
### მონაცემთა სტრუქტურები და ფუნქციები
**threads/thread.h**
```
struct thread
{
  ...
  struct hash supp_page_table;
  ...
}
```
**vm/page.h**
```
struct supp_page_entry
{
	struct hash_elem elem;

	void * upage;
	void * kpage;

	struct file* file;
	off_t offs;
	uint32_t read_bytes;
	uint32_t zero_bytes;
	bool writable;
};

void init_supp_page_table(struct hash* table);
void destroy_supp_page_table(struct hash* table);
bool insert_into_page_tables(struct file *file, off_t ofs, uint8_t *upage,// uint8_t *kpage,
              uint32_t read_bytes, uint32_t zero_bytes, bool writable);
bool stack_grow(void * fault_addr);
bool mmap_into_page_tables(struct file *file, off_t ofs, uint8_t *upage,
              uint32_t read_bytes, uint32_t zero_bytes, bool writable);
struct supp_page_entry * get_page(void * upage);
```
მიუხედავად იმისა, რომ მისამართთა ტრანსლაცია უკვე მოცემული გვაქვს `pagedir`-ის მეშვეობით, რომელიც იყენებს `page directory` და `page table`-ებს. ვირტუალური მისამართების მათში ჩაწერა გულისხმობს ფიზიკური მეხსიერების გამოყოფას, ჩვენ კი გვინდა იუზერ პროგრამის ჩატვირთვისას მისთვის საჭირო სეგმენტების ვირტუალური მისამართები დავიმახსოვროთ, ისე რომ რეალური მეხსიერება არ გამოვყოთ. ამისთვის გვადგება `supp_page_table` სტრუქტურა, რომელიც ჰეშმებს წარმოადგენს. ის ინდივიდუალურია პროცესისთვის და შეიცავს `supp_page_entry` სქტრუქტურებსს, რომელიც პროცესის ვირტუალური ფეიჯის მისამართებს აერთიანებს სხვა საჭირო ველებთან ერთად. ეს ველებია:
- `upage` - ვირტუალური ფეიჯის მისმართი. შეიძლება ჩაითვალოს სტრქუტურის 'მთავარ' ველად, რადგან მისი მეშვეობით ხდება ჰეშირება და ჰეშმეპში სტრქუტურის ძებნა.
- `file` - იუიზერ პროგრამის შესაბამისი ფაილი, რომლის სეგმენტების უნდა დაიმეპოს და შეგდომ ჩაიტვირთოს მეხსიერებაში
- `offs`- ფაილის დასაწყისიდან მანძილი, სადაც მდებარეობს ვირტუალური ფეიჯის შესაბამისი მეხსიერება ფაილში.
- `read_bytes` - თუ რამდენიმ არანულოვანი ბაიტი უნდა იყოს წაკთხული ფაილიდან მოცემული ვირტუალური ფეიჯის შესაბამისი ფიზიკური ფრეიმის შესავსებად
- `zero_bytes` - ნულოვანი ბაიტები რომელიც იტვირთება ფრეიმის ბოლოში, თუ ჩასატვირთი ფაილის ინფორმაცია ნაკლებია ფეიჯის ზომაზე
- `writable` - აქვს თუ არა პროგრამას მოცემულ სეგმენტზე წერის ნებართვა

### ალგორითმები
`supplemental page table`-ის ერთ-ერთი მთავარი ფუნქციაა `lazy loading`-ის განხორციელება.
როდესაც პროგრამა ემზადება გასაშვებად, მისი თითოუელი სეგმენტის თითოეული ფეიჯი ინახება `supp_page_table` სტრუქტურაში, ისე რომ არ ხდება მეხსიერების წაკითხვა ფაილიდან და ფიზიკურ მეხსიერებაში ჩაწერა. თუმცა ვინხავთ ინფრომაციას, თუ როგორ უნდა მოხდეს წაკითხვა ფაილიდა, მაშინ როდესაც პროგრამა მოცემული ფეიჯის მისამარის რეალურ წვდომას მოითხოვს. ამ ეტაპზე ასევე შეგვიძლია გავარვკიოთ მოცემული იუზერ პროგრამის პირველი სეგემენტის მისამართი, და დავიმახსოვროთ, რომელიც `PHYS_BASE`-თან ერთად, უიზერ პრაგრამის სკოუპს გვაძლევს და მისამარების ვალიდაციაში გვეხმარება. ეს ყველაფერი ხდება `process.c` ფაილის, `load_segment()`  ფუნქციაში. აღსანიშნავია, რომ `setup_stack()` ფუქნციაში, მიუხედავად იმისა რომ რეალურად გამოიყოფა ერთი ფეიჯი ფიზიკური მეხსიერება, ასევე აუცილებელია მისი ვირტუალური ადრესის შენახვაც.

თავად რეალურ მისამართებზე წვდომას უიზერ პროგრამა მოითხოვს მოქმედების პროცესში. ჩაუტვირთავ მეხსიერებაზე წვდომა შეიძლება მოითხოვოს სისტემქოლის გამოძახებისას, გადაცემული არგუმენტების ან სტეკ პოინტერის სახით, ან გაშვებულად ყოფნის ფერიოდში `page_fault`ექსეფშენის ამოგდებით. ამ შემთხვევების ჰენდლინგს ვაკეთებს `exception.c` და `syscall.c` ფაილებში. ორივე შემთხვევაში ძირითადად გვექნება ორი მოთხოვნა, ან ჩაუტვირთავი სეგმენტის ფეიჯზე წვდომა ან სტეკის გაზრდა. პირველ შემთხვევაში იმ მოცემული ვირტუალური მეხსიერების შესაბამის ფეიჯს, რომელზედ `page fault` მოხდა, ვიღებთ supp_page_table ჰეშმეპიდან, `frame_alloc()`-ის მეშვეობით გამოვყოფთ ფრეიმს, და `file_read_at()`-ით ვწერთ ფრეიმში `supp_page_entry`-ში შენახული ველების მეშვებით შესაბამისი ფაილიდან. ამის შემდეგ `pagedir_ser_page()`ის მეშვეობით ვირტუალურ მესხიერებას ვაკავშირებთ ფიზიკურ მისამართთან. 

მეორე ვარიანტი გვაქვს სტეკის გაზრდის მოთხოვნა. თუ page `fault`ის გამომწვევი მისამართი არის სტეკ პოინტერიდან 32 ბაიტის დაშორებით, და  არ აჭარბებს 8 მეგაბაიტის სხვაობას სტეკის დასაწყისიდან, ვიძახებთ ფუნქციას `stack_grow()`, რომელიც მეხსიერებაში ტვირთავს დამატებით 1 ფეიჯი ზომის მეხსიერებას `fault`-ის გამომწვევი სტეკ მისამართის შესაბამისად.

### სინქრონიზაცია
`supplemental_page_table`-ის იმპლეენტაციისას, არ გვქონია საჭიროება სინქრონიზაციის მექანიზმები გამოგვეყენებინა, რადგან ეს ჰეშმები ინდივიდუალურია თითოეული იუზერ პროგრამისთვის, ამიტომ შეუძლებელია კონფლიქტების წარმოქმნა.

## 3. Memory Mapping
### მონაცემთა სტრქუტურები და ფუნქციები
**thread.h**
```
struct thread
{
  ...
  struct list mmap_list;
  int map_id_count;
  ...
}

struct mmap_
{
  int map_id;
  struct supp_page_entry * p;
  struct list_elem elem;
};

```
**syscall.c**
```
int mmap(int fd, void * addr);
void munmap(int mmap_id);
```

ფაილების დამეპვისთვის ვირტუალურ მეხსეიერებასთან ვიყენებთ mmap_ სტრუქტურას, რომელიც მოთავსდება თითოეული იუზერ პროგრამის mmap_list-ში. ის შეიცავს 
- `map_id` - თითოეულ დამეპილ ფაილს თავისი id აქვს. შესაძლოა ერთ ფაილის რამდნეიმე ფაიჯი იყოს დამეპილი, ამიტომ შეიძლება ლისტში ერთი აიდის მქონე რამდენიმე mmap_ სტუქტურა ეყაროს.
- `p` - შესაბამისი ვირტუალური ფეიჯი.

### ალგორითმები
რეალურად გვიწევს `syscall.c`-ში ორი ახალი სისტემქოლის შექმნა. `mmap`-ის შემთხვევაში გადავუყვებით დასამეპ ფაილს, და მის თითოეულ ფეიჯისთვის გამოვყოფთ როგორც `supp_page_table`, ასევე `mmap_` სტრურტურას. ეს ყველაფერი ხდება  `mmap_into_page_table()` ფუნქციის მეშვეობით. პროცესი მიმდინარეობს ზემოთ ნახსენები იუზერ პროგრამის ფაილის დამეპვის ანალოგიურად. munmap-ის შემთხვევაში, გადავუყვევით ლისტს და გადმოცემული ინდექსის მქონე `mmap_` სტრუქტურებიდან `supp_page_table`-იდან ვშლით supp_page_entry სტრუქტურას, და ვათავისუფლებთ როგორც `supp_page_table` ასევე `mmap_` სტრუქტურას. ასევე ვხურავთ შესაბამის დამეპილ ფაილს. უნდა აღინიშნოს რომ `unmap` გამოიძახება პროცესის `exit`-ის დროს.

### სინქრონიზაცია
მოცემული სტრუქტურები ერთ იუზერ პროგრამას ეკუთვნიან, ამიტომ არი არის კონფლიქტების საჭიშროება და შესაბამისად არც სინქრონიზაციის საჭიროება.
