პროექტი 2: იუზერ პროგრამები
============================================

## ჯგუფის წევრები

* გიორგი დანელია <gdane14@freeuni.edu.ge>
* ლუკა კირია <lkiri15@freeuni.edu.ge>
* ირაკლი ქანთარია <ikant14@freeuni.edu.ge>
* საბა თათანაშვილი <stata14@freeuni.edu.ge>

## ტასკი 1: არგუმენტების გადაცემა

### დატა სტრუქტურები

შეცვლილი მეთოდები:
```C
tid_t process_execute (const char *file_name);
static void start_process (void *file_name_);
```

### ალგორითმი
`process_execute`-ში ვიღებთ პროცესის სახელს და მთლიანი სტრინგის ნაცვლად მას გადავცემთ `thread_create`-ს.

`start_process`-ში `strtok_r` ის გამოყენებით `file_name`-ს ვყოფთ ტოკენებად და მასივში ვაგდებთ იმ მისამართს, რა ადგილზეც კონკრეტული არგუმენტი ჩაკოპირდება სტეკში. ბოლოს, სტეკში ვყრით არგუმენტებს, მისამართს და ზომას.

### სინქრონიზაცია

არ შეგვქმნია სინქრონიზაციის საჭიროება.

### ლოგიკა

განსაკუთრებული ალგორითმის მოფიქრება არ დაგვჭირვებია, უბრალოდ 80 x 86 Calling Convention-ს მივყევით.

## ტასკი 2: პროცესის კონტროლის სისტემქოლები

### დატა სტრუქტურები

###### In thread.h

```C
struct child_process
  {
    tid_t cp_id;                        /* Child process id */
    int status;                         /* Child process status */
    bool created;                       /* Child loaded sucessful */
    struct semaphore sema;              /* Semaphore for parent-child communication */

    struct list_elem cp_list_elem;      /* List element for child process id list */
  };

struct thread
  {
    ...
#ifdef USERPROG
    /* Owned by userprog/process.c. */
    struct list cp_list;                /* List containing child process id */
    struct child_process * self;        /* Current process */
    ...
#endif
...
  };
```

### ალგორითმი

ყველა სისტემქოლის იმპლემენტაცია ხდება `syscall_handler()`-ში და ძირითადად გამოიყენება ფუნქციები `process.c`-დან

* Practice

იმლემენტაცია საკმაოდ პირდაპირია. `eax` რეგისტრში ვწერთ დასაბრუნებელ მნიშვნელობას, რაც არის ერთით გაზრდილი გადმოცემული ინტეჯერი.

* Halt

ხდება `shutdown_power_off()`-ის გამოძახება.

* Exit

ამ სისტემქოლის იმპლემენტაციისთვის საჭიროა კომუნიკაცია მშობელს და შვილს შორის. ეს ხდება სწორედ `child_process` სტრუქტურის მეშვეობით. `syscall_handler()`-ში გადმოცემულ სტატუს არგუმენტს ვწერთ არა მხოლოდ `eax` რეგისტრში, არამედ `child_process` სტრუქტურის `status` ველში. რახან ნებისმიერ პროცესს აქვს  მისი შვილობილი პროცესების `child_process` სტრუქტურაზე ლისტის მეშვეობით წვდომა, აქვთ ასევე წვდომა მის სტატუზე. `syscall_handler()`-შივე ვიძახებთ `thread_exit()`-ს, რომელიც შემდეგ გამოიძახებს `process_exit()` ფუნქციას. ამ უკანასნელში ხდება გახსნილი ფაილების დახურვა, შვილობილი პროცესების მეხსიერების გათავისუფლება და სემაფორის გაზრდა(იხ. სინქრონიზაცია).
უნდა ავღნიშნოთ რომ ინიციალიზაციისას `status` ველის მნიშვნელობა არის -1, რადგან  თუ პროცესის შეწყვეტა მოხდა კერნელიდან, -1 არის სწორედ ის მნიშვნელობა, რომელსაც მშობელი წაიკითხავს შვილის exit status-ად.

* Exec

`syscall_handler()`-დან ვიძახებთ `process_execute()`-ს, სადაც გადმოცემული არგუმეტიდან ამოვიღებთ პროცესის სახელს და `thread_create()`-ის მეშვეობით ვქმნით ახალ პროცესს. `Thread.c` ფაილში, `thread_create()` ფუქნციაში ვაკეთებს `child_process` სტრუქტურის და მისი ველების ინიციალიზაციას. ახლად შექმნილი ნაკადი `start_process()`-ის მეშვეობით იძახებს `load()` ფუნქციას, რომელიც მეხსიერებაში ტვირთავს პროცესს. მშობელი პროცესი ელოდება სანამ დასრულდება შვილის მეხსიერებაში ჩატვირთვა და შედეგის მიხედვით აბრუნებს ან შვილის id-ს ან -1-ს. ამ ყველაფრისთვის გვჭირდება სინქრონიზაციის მექანიზმი(იხ. ქვემოთ).

* Wait

ვიყენებთ `process_wait` ფუნქციას. გადმოცემული id-ს მეშვეობით, მშობელი პროცესი ეძებს ამ id-ს მქონე შვილს. ამას ვაკეთებთ იმ ლისტის მეშვეობით, სადაც შვილობილი პროცესების შესაბამისი `child_process` სტრუქტურები ინახება. გადმოცემული id-ს მქონე შვილის არ პოვნის შემთხვევაში ვაბრუნებთ -1-ს. პოვნის შემთხვევაში კი -1-ს.

### სინქრონიზაცია

`Exit`, `Exec` და `Wait` ქოლებისთვის აუცილებელია სინქრონიზაციის მექანიზმები, `halt`-სა და `practice`-ს არ სჭირდება.

`child_process` სტრუქტურაში ვინახავთ სემაფორას, რომელსაც ორი ფუნქცია გააჩნია; `process_execute()`-ში მშობელი იძახებს `sema_down()`-ს მას შემდეგ რაც შექმნის ახალ პროცესს. `start_process()`-ში შვილი პროცესი იძახებს `sema_up()`-ს მას შემდეგ რაც წარმატებით ან წარუმატებლად მოხდება `load()` ფუნქციის გამოძახება. ამის მშობელი ელოდება შვილის ჩატვირთვის შედეგს და აბრუნებს შესაბამის მნიშვნელობას. `process_wait()`-ში, ნაპოვნი შვილის შესაბამის სემაფორაზე მშობელი აკეთებს `sema_down()`-ს ამით ის ელოდება შვილობილი პროცესის ტერმინირებას. შვილობილი პროცესი `sema_up()`-ს იძახებს `process_exit()` ფუქნციაში.

### ლოგიკა

თავდაპირველად განვიხილეთ პროცესებს შორის კომუნიკაციისთვის ალტერნატიული მეთოდები, მაგალითად მშობელს და შვილს პირდაპირ ქონოდათ წვდომა ერთმანეთის გარკვეულ ველებზე. თუმცა გაზიარებული მეხსიერების პრინციპი ყველაზე მოსახერხებელი გამოდგა. სინქრონიზაციისთვის სემაფორა ალტერნატივასთან შედარებით უკეთესი გადაწყვეტილება იყო, როგორც იდეურად, ასევე პრაქტიკულად.

## ტასკი 3: ფაილური ოპერაციების სისტემქოლები

### დატა სტრუქტურები

###### In thread.h

```C
struct file_
  {
    int fd;                           /* File descriptor */
    struct file * file;               /* File */

    struct list_elem _file_elem;      /* List elem */
  };

struct thread
  {
    ...
#ifdef USERPROG
    ...
    struct list file_list;              /* File_ list */
    int fd_count;                       /* File descriptor count */
    ...
#endif
...
  };
  
struct child_process
  {
  ...
    struct file *to_deny;                /* File to deny write*/
  ...
  };
  
```

###### In syscall.c

```C
/* Lock for synchronization */
struct lock synch;
```

### ალგორითმი

რადგან ნაკადის სტრუქტურაში ვინახავთ სტრუქტურების ლისტს, რომლებიც გახსნილ ფაილზე მიუთითებენ, ფაილური სისტემქოლების დიდი ნაწილისთვის ამ ლისტზე იტერაციის მეშვეობით ვამოწმებთ არის თუ არა ფაილი ამ პროცესის მიერ გახსნილი. ფაილთან ერთად ვინახავთ ფაილდესკრიპტორსაც თითოეული ფაილისთვის და ნაკადის სტრუქტურაში გვაქვს `fd_count` ცვლადი რომლის მეშვეობითაც ვიგებთ შემდეგი ფაილი რომელ ფაილ დესკრიპტორს შევუსაბამოთ. ასევე უნდა აღინიშნოს რომ `syscall_handler`-ში ნებისმიერი სისტემქოლის გამოძახებამდე ხდება გადმოცემული არგუმენტების ვალიდურობი შემოწმება, რაც მოიცავს მათი უშუალო მისამართების და მიმთითებლების შემთხვევაში, მათ მიერ მითითებული მისამართების ყოფნას იუზერ პროგრამის მეხსიერების ფარგლებში. ასევე, მოცემული სისტემქოლებითვის ვიყენებთ `src\filesys\file.h` და `src\filesys\filesys.h`-ში აღწერილ მეთოდებს. 

### სინქრონიზაცია

`syscall.c`-ში აღწერილი გვაქვს ლოქი `struct lock synch`, რომელიც გარანტიას გვაძლევს რომ ფაილზე ნებსმიერი მოქმდებე ხდება ატომურად.

### ლოგიკა
სინქრონიზაციის მექანიზმად შეგვეძლო როგროც ლოქის ასევე სემაფორის გამოყენება. ჩვენი გადაწყვეტილება არ ეყრდნობა რაიმე კონკრეტულ მიზეზს. ტასკის დარჩენილი ნაწილის იმპლემენტაცია საკმაოდ მტკიცედ არის განსაზღვრული მოცემული სისტემქოლების ფუნქციონალის მიერ, შესაბამისად შესაძლებელი დიზიანის ვერსიები არ გამოირჩეოდა დიდი ვარიაციით.
