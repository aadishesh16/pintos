პროექტი 3: ფაილური სისტემები
==========================================

## ჯგუფის წევრები

* გიორგი დანელია <gdane14@freeuni.edu.ge>
* ლუკა კირია <lkiri15@freeuni.edu.ge>
* ირაკლი ქანთარია <ikant14@freeuni.edu.ge>
* საბა თათანაშვილი <stata14@freeuni.edu.ge>

## Task 1: File Cache

### მინაცემთა სტრუქტურები და ფუნქციები
**cache.c/cache.h**
```
struct cache_entry cache[64];

struct cache_entry{
	block_sector_t sector;
	bool filled;
	bool dirty;
	bool accessed;
  void* data;
};

void cache_read(block_sector_t sector,  uint8_t* buffer, int sector_ofs, off_t bytes_read, int chunk_size);
void cache_write(block_sector_t sector,  uint8_t* buffer, int sector_ofs, off_t bytes_written, int chunk_size);

struct lock cache_lock;
```
ქეშის რეალიზაცია გვაქვს 64 ზომის სტატიკური მასივით. თითოეული ელემენტი კი არის cache_entry სტრუქტურა, ორმელიც შეიცავს მიმთითებელს 
1 სექტორის ზომის დატაზე, რომელშიც დისკიდან წამოღებული ბლოკები ჩაიწერება. 
`filled` - აღნიშნავს არის თუ არა დაკავებული მასივის მოცემული ენთრი
`dirty`  -  აღნიშნავს არის თუ არა data-ში ცვლილება, რომელიც დისკზე უნდა გადაიწეროს
`accessed` -  გვჭირდება ევიქშენის ალგორითმისთვუს

### ალგორითმები
ქეშის მუშაობის პრინციპი სიკაოდ პირდაპირია. inode.c-ში ბლოკების read და write ფუნქციების მაგივრად `cache_read` და `cache_write` 
ფუნქციებს ვიყენებთ. 

სასურველი სექტორის მოძებნა ხდება მასვიში sector ველის მიხედვით. eviction-ისთვის გამოიყენება second chance ალგორითმი.
ანუ მასივის გადაყოლისას ვეძებთ accessed ენთრიებს. პოვნის შემთხვევაში ვანულებთ მის accessed ველს და ვაგრძლებთ ძებნას. სანამ 
accessed = 0-იან ენთრის არ ვიპოვით ამოსაგდებად. მასივის ბოლოში გასვილსას, მასივის თავში ვბრუნდებით და გარანტია გვაქვს რომ ნამდვილად ვიპოვით
არა-accessed ენთრის.

### სინქრონიზაცია
სინქრონიზაციისთვის გამოიყენება მხოლოდ ქეშის ერთი ლოქი cache_lock, რომელის არება ხდება ნებისმიერი cache_read ან cache_write ის შემთხვევაში.

### რაციონალი
შესაძლო იყო ქეშის სინქრონიზაციისთვის უფრო კომპლექსური მექანიზმის შემოღება, თუმცა ჩვენმა მეთოდმაც საკმაოდ სასურველი შედეგი გამოიღო
და შესამჩნევი უპირატესობა მოგვცა ქეშის გარეშე არსებულ იმპლემენტეციიასთან შედარებით.
 
## Task 2: Extensible Files

### მონაცემთა სტრუქტურები და ალგორითმები
***inode.c/inode.h***
```

struct inode_disk
  {

    ...
    
    uint32_t dir_index;
    uint32_t indir_index;
    uint32_t double_indir_index;
    ...

    block_sector_t ptr[12];
  };
  
  struct inode
  {
    struct list_elem elem;              /* Element in inode list. */
    block_sector_t sector;              /* Sector number of disk location. */
    int open_cnt;                       /* Number of openers. */
    bool removed;                       /* True if deleted, false otherwise. */
    int deny_write_cnt;                 /* 0: writes ok, >0: deny writes. */
    struct inode_disk data;             /* Inode content. */
    struct lock lock;
};

static int inode_allocate(struct inode_disk* inode_disk, off_t init_length);
```
ამ ტასკისთვის ცვილებების შევიტანეთ inode_disk სტრუტურაში და შესაბამისად inode სტქუტრუაშიც რათა 3 დონის სექტორების გამოყოფა შეგვეძლოს.
inode_disk, როგორც ფაილის ჰედერის ანალოგი მეხსიერებაში, ინახავს 10 ცალი სექტორის შესაბამის ინდექსს დისკზე(block_setor_t ტიპის ცვლადში),
ერთ ცალ სექტორის ინდექს, რომელიც შეესაბამება 128 ცალი სექტორებზე მიმთითებელი ინდექსებისგან, და ერთ ცალ ინდექსს რომელსაც შეესაბამება
ორი 128 სექტროზე მიმთითებელი შუამავალი სექტორები. ამ სამი სახის მიმთითებლის რეპრეზანტაცია ხდება 12 ელემენტიანი ptr მასივი სახით.

dir_index, indir_index და double_indir ინდექს ცვლადები მიუთითებს თუ სად უნდა შევინახოთ ახლად გამოყოფილი სექტორის ინდექსი. მაგალითად 
dir_index = 12, indir_index = 4, double_indir_index = 10 ნიშნავს რომ შემდეგი გამოყოფილი სექტორი უნდა ჩაიწეროს მე-10 ინდექსზე იმ სექტორში,
რომლის ინდექსიც წერია კონკრეტული სექტორის მე-4 ინდექსზე, ამ უკანასკნელი სექტორის ნომერი კი წერია ფაილის ჰედერის ptr მასივის მე-12 
ინდექზე. ასევე მაგალითად თუ dir_index ნაკლებია 10ზე, ესე იგი გამოსაყოფი სექტორის ინდექსი პირდაპირ ეწერება ptr მასივის კონკრეტულ ინდექსზე.
კონკრეტული დიზანი საკმაოდ მოსახერხებელია `inode_allocate()` ფუქნციისთვის. რომელიც გამოიყენებს დამხმარე ფუნქციებს:
`inode_indirect_allocate`
`inode_double_indirect_allocate`
`inode_double_indirect_allocate_helper`

ეს ფუნციები გამოიყოფა სხვადასხვა დონის სექტორებზე მიმთითებლების გამოსაყოფად.
###  ალგორითმები
მოცემული დავალებისთვის inode_allocate() ფუნქცია საკმაოდ პირდაპირ მუშაობს. ის გამოიძახება inode_create() ფუნქციაში, და inode_write_at
ფუნქციაში, როდესაც ჩაწერის პიზიციას დამატებული ჩასაწერი ბაიტების რაოდენობა აღემატება ფაილის ზომას. ორივე შემთხვევაში, ვითვლით ახლიდან 
დასამატებელი სექტორების რაოდენობას, გამოვყოფთ ახალ სექტორებს და მათ ინდექსებს inode_disk-ში შენახული block_sector_t ცვლადის მეშვეობით 
ვწერთ წინდა დაკევებული ინდექსების უშუალოდ მომდევნო ადგილზე. ჯერ ვავსებს directed სექტორებს, შემდეგ indirected და ას შემდეგ double_indirected.

ზემოხსენებულ პროცესში ხელს გვიწყობს დამხმარე ფუნქციები როგორიცაა bytes_to_sector(), რომელიც აბრუნებს რამდენი სექტორი არის საჭირო ბაიტების გარკვეული
რაოდენობის ჩასატევად, და byte_to_sector() რომელიც გვუბნება მოცემული ბაიტი რომელ სექტორში ვარდება და აბრუნებს სექტორის დისკის ინდექსს.

## სინქრონიზაცია
მოცემული დავალებისთვის განსაკუთრებული სინქრონიზაცია არ გაგვიკეთებია, რადგან ქეშის საკუთრივი ლოქი თვითონ აგვარებს შესაძლო სინქრონიზაციის პრობლემებს.

###  რაციონალი
inode-ში ვინახავთ მთლიან inode_disk სტრუქტურას, რომელიც რეალურად ყოველთვის 512 ბაიტია და მეხსიერებისთვის არა საჭირო თავისუფალ ნაწილს შეიცავს. შეგვეძლო inode_diskის საჭირო 
ველები ყოველ ჯერზე გადმოგვეკოპირებინა inode სტრეუქტურაში, ეს არ ჩავთვალეთ საჭიროდ რადგან დაკავებული მეხსიერება არ მივიჩნიეთ პრობლემატურად.

## Task 3: Subdirectories
### მონახემთა სტრუქტურები და ფუნქციები
**inode.h**
struct inode_disk
  {
    ...
    off_t offs;
    bool isdir;
    block_sector_t parent;
    uint32_t file_num;
    struct lock inode_lock;
    ...
};
იმისათვის რომ ერთმანეთისგან გავარჩიოთ ფაილი და დირექტორია, inode_disk სტრუქტურაში ვინახავთ isdir ცვლადს, ასევე დირექტორიებში მოძრეოაბისთვის
ვინახავთ მოცემული ფაილის.დირექტროიის მშობლის სექტორს.
**thread.h**
```
struct thread{
  ...
   struct inode *cwd;
  ...
}
```
სრედის სტრუქტურაში ვინახავთ current working directory-ს აინოუდს. ის ფაქტი რომ აინოუდს ვინახავთ და არა დირექტორიას, საშუალებას გვაძლევს
დავხუროთ cwd.
file_num-ის მეშვეობით ვითვლით დიექტორიაში არსებული entry-ების რაოდენობას.

### ალგორითმები
დამხმარე მეთოდი, რომელიც თითქმის ყველა სისტემქოლის შესრულებაში გვეხმარება არის `find (const char *name, char name_[NAME_MAX +1], struct dir **dir_)`,
რომელიც გადმოცემული გზის მეშვეობით dir ცვლადში გვიწერს იმ დირექტორიას, სადაც საძლებნი ფაილი არსებობს. ეს საკმაოდ მოსახერხებელია, რადგან
ნებისმიერი სისტემქოლის გამოძახების შემთხევაში გვაძლევს დირექტორიას და ამ დირექტორიაში საძებნ ფაილს, ახალი დირექტორიის ან ფაილის შექმნას,
ან შეცვლას `directory.h` ის ფუნქციები აგვარებენ.

### სინქრონიზაცია
თითოებული ინოუდ დისკისთვის გვაქვს ლოქი, რომელიც გამოიყენება დირექტორიის წაკითვისას `dir_readdir` და `dir_lookup` ფუნქციებში, და დირექტორიის
მოდიფიკაციისას  `dir_add` და `dir_remove` ფუნქციებში.

### რაციონალი
ჩვენს მიერ შემოტანილმა ფუქნციებმა, როგორიცაა  `find`, საშუალება მოგვცა უკვე არსებული filesys და directory ფაილის ფუნქციების ძალზედ 
მცირე მოდიფიკაციებით შეგვექმნა საბდირექტორიების ფუქნციონალი
